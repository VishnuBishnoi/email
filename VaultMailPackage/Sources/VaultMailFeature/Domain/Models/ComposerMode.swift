import Foundation

/// Composition mode for the email composer.
///
/// Each mode determines how the composer is pre-filled (recipients,
/// subject, body, attachments) and which RFC 2822 headers are set.
///
/// Conforms to `Identifiable` for use with SwiftUI `.sheet(item:)`.
///
/// Spec ref: Email Composer spec FR-COMP-01
public enum ComposerMode: Identifiable, Sendable {
    /// New blank email.
    case new(accountId: String)
    /// Reply to a single sender.
    case reply(email: ComposerEmailContext)
    /// Reply to all recipients.
    case replyAll(email: ComposerEmailContext)
    /// Forward an email.
    case forward(email: ComposerEmailContext)
    /// Edit an existing draft.
    case editDraft(email: ComposerEmailContext)

    public var id: String {
        switch self {
        case .new(let accountId):
            "new-\(accountId)"
        case .reply(let ctx):
            "reply-\(ctx.emailId)"
        case .replyAll(let ctx):
            "replyAll-\(ctx.emailId)"
        case .forward(let ctx):
            "forward-\(ctx.emailId)"
        case .editDraft(let ctx):
            "editDraft-\(ctx.emailId)"
        }
    }

    /// The account ID for this composition.
    public var accountId: String {
        switch self {
        case .new(let accountId):
            accountId
        case .reply(let ctx), .replyAll(let ctx), .forward(let ctx), .editDraft(let ctx):
            ctx.accountId
        }
    }
}

/// Sendable snapshot of an `Email` model's fields for composition.
///
/// SwiftData `@Model` classes are not `Sendable`, so we extract
/// the relevant fields into this lightweight struct before presenting
/// the composer sheet.
///
/// Spec ref: Email Composer spec FR-COMP-01
public struct ComposerEmailContext: Sendable, Equatable {
    public let emailId: String
    public let accountId: String
    public let threadId: String
    public let messageId: String
    public let inReplyTo: String?
    public let references: String?
    public let fromAddress: String
    public let fromName: String?
    public let toAddresses: String      // JSON array
    public let ccAddresses: String?     // JSON array
    public let bccAddresses: String?    // JSON array
    public let subject: String
    public let bodyPlain: String?
    public let bodyHTML: String?
    public let dateSent: Date?
    public let isDraft: Bool
    public let attachmentIds: [String]

    public init(
        emailId: String,
        accountId: String,
        threadId: String,
        messageId: String,
        inReplyTo: String? = nil,
        references: String? = nil,
        fromAddress: String,
        fromName: String? = nil,
        toAddresses: String = "[]",
        ccAddresses: String? = nil,
        bccAddresses: String? = nil,
        subject: String,
        bodyPlain: String? = nil,
        bodyHTML: String? = nil,
        dateSent: Date? = nil,
        isDraft: Bool = false,
        attachmentIds: [String] = []
    ) {
        self.emailId = emailId
        self.accountId = accountId
        self.threadId = threadId
        self.messageId = messageId
        self.inReplyTo = inReplyTo
        self.references = references
        self.fromAddress = fromAddress
        self.fromName = fromName
        self.toAddresses = toAddresses
        self.ccAddresses = ccAddresses
        self.bccAddresses = bccAddresses
        self.subject = subject
        self.bodyPlain = bodyPlain
        self.bodyHTML = bodyHTML
        self.dateSent = dateSent
        self.isDraft = isDraft
        self.attachmentIds = attachmentIds
    }

    /// Convenience initializer to create a context snapshot from a SwiftData Email model.
    ///
    /// Email @Model objects are not Sendable, so this creates a lightweight
    /// Sendable copy for the composer to use across concurrency boundaries.
    public init(from email: Email) {
        self.init(
            emailId: email.id,
            accountId: email.accountId,
            threadId: email.threadId,
            messageId: email.messageId,
            inReplyTo: email.inReplyTo,
            references: email.references,
            fromAddress: email.fromAddress,
            fromName: email.fromName,
            toAddresses: email.toAddresses,
            ccAddresses: email.ccAddresses,
            bccAddresses: email.bccAddresses,
            subject: email.subject,
            bodyPlain: email.bodyPlain,
            bodyHTML: email.bodyHTML,
            dateSent: email.dateSent,
            isDraft: email.isDraft,
            attachmentIds: email.attachments.map(\.id)
        )
    }
}

/// Pre-filled composer fields based on composition mode.
///
/// Generated by `ComposeEmailUseCase.buildPrefill(mode:userEmail:)`.
///
/// Spec ref: Email Composer spec FR-COMP-01
public struct ComposerPrefill: Sendable, Equatable {
    public let toAddresses: [String]
    public let ccAddresses: [String]
    public let bccAddresses: [String]
    public let subject: String
    public let bodyPrefix: String
    public let inReplyTo: String?
    public let references: String?
    public let forwardedAttachmentIds: [String]

    public init(
        toAddresses: [String] = [],
        ccAddresses: [String] = [],
        bccAddresses: [String] = [],
        subject: String = "",
        bodyPrefix: String = "",
        inReplyTo: String? = nil,
        references: String? = nil,
        forwardedAttachmentIds: [String] = []
    ) {
        self.toAddresses = toAddresses
        self.ccAddresses = ccAddresses
        self.bccAddresses = bccAddresses
        self.subject = subject
        self.bodyPrefix = bodyPrefix
        self.inReplyTo = inReplyTo
        self.references = references
        self.forwardedAttachmentIds = forwardedAttachmentIds
    }
}

/// A recipient token displayed in the recipient field.
///
/// Spec ref: Email Composer spec FR-COMP-01, FR-COMP-04
public struct RecipientToken: Identifiable, Equatable, Sendable, Hashable {
    public let id: String
    public let email: String
    public let displayName: String?
    public let isValid: Bool

    public init(
        id: String = UUID().uuidString,
        email: String,
        displayName: String? = nil,
        isValid: Bool = true
    ) {
        self.id = id
        self.email = email
        self.displayName = displayName
        self.isValid = isValid
    }

    /// Display text: name if available, otherwise email.
    public var displayText: String {
        displayName ?? email
    }
}

/// Result of dismissing the composer.
///
/// The parent view uses this to determine follow-up actions
/// (e.g., starting undo-send countdown on `.sent`).
public enum ComposerDismissResult: Sendable {
    /// Email was queued for sending (undo-send window starts).
    case sent(emailId: String)
    /// Draft was saved.
    case savedDraft
    /// Draft was discarded (empty content).
    case discarded
    /// User cancelled without changes.
    case cancelled
}

/// An attachment item for the composer UI.
///
/// Lightweight value type for display; not a SwiftData model.
///
/// Spec ref: Email Composer spec FR-COMP-01
public struct AttachmentItem: Identifiable, Equatable, Sendable {
    public let id: String
    public let filename: String
    public let sizeBytes: Int
    public let mimeType: String
    public let localPath: String?
    public let isDownloading: Bool

    public init(
        id: String = UUID().uuidString,
        filename: String,
        sizeBytes: Int,
        mimeType: String,
        localPath: String? = nil,
        isDownloading: Bool = false
    ) {
        self.id = id
        self.filename = filename
        self.sizeBytes = sizeBytes
        self.mimeType = mimeType
        self.localPath = localPath
        self.isDownloading = isDownloading
    }

    /// Size formatted for display (e.g., "2.4 MB", "128 KB").
    public var formattedSize: String {
        let formatter = ByteCountFormatter()
        formatter.allowedUnits = [.useKB, .useMB, .useGB]
        formatter.countStyle = .file
        return formatter.string(fromByteCount: Int64(sizeBytes))
    }
}
